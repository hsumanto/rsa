apply plugin: 'java'
apply plugin: 'application'

import java.nio.file.Files
import java.nio.file.Paths

mainClassName = 'org.vpac.ndg.cli.Client'

sourceSets {
    filter
}

dependencies {
    compile (
        'commons-cli:commons-cli:1.3.1',
        'commons-io:commons-io:2.5',
        'com.martiansoftware:nailgun-examples:0.9.1',
        'org.jsoup:jsoup:1.9.2',
        "org.springframework:spring-web:$springVersion",
        project(':storagemanager'),
    )

    filterCompile (
        project(path: ':rsaquery')
    )

    runtime (
        project(path: ':rsaquery', configuration: 'filter'),
        sourceSets.filter.output,
    )

    testCompile (
        'com.carrotsearch:junit-benchmarks:0.4.0',
        "org.springframework:spring-test:$springVersion",
        sourceSets.main.output,
    )

    testRuntime (
        'org.apache.commons:commons-dbcp2:2.1.1',
    )
}

jar {
    manifest {
        attributes("Implementation-Title": applicationName)
    }
}

startScripts {
    // Workaround for application plugin setting the wrong classpath for the
    // config directory: It's in src/dist/config, which gets copied to
    // APP_HOME/config.
    // https://issues.gradle.org/browse/GRADLE-2333
    // http://stackoverflow.com/a/18712556/320036
    doLast {
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile = file getUnixScript()
        windowsScriptFile.text = windowsScriptFile.text.replaceFirst(
            /%APP_HOME%\\lib\\config(:|$)/,
            '%APP_HOME%\\config$1')
        unixScriptFile.text  = unixScriptFile.text.replaceFirst(
            /APP_HOME\/lib\/config(:|$)/,
            'APP_HOME/config$1')
        windowsScriptFile.text = windowsScriptFile.text.replaceFirst(
            /%APP_HOME%\\lib\\filter(:|$)/,
            '%APP_HOME%\\lib$1')
        unixScriptFile.text  = unixScriptFile.text.replaceFirst(
            /APP_HOME\/lib\/filter(:|$)/,
            'APP_HOME/lib$1')
    }
}

installDist {
    // Create a symlink to the primary config directory.
    // This is rather complicated because the config directory needs to exist
    // in src/dist so that it becomes part of the classpath, but in the end we
    // want it to be a symlink to a common config directory.
    //
    // 1. During task setup, delete any old symlinks that would prevent the
    //    dummy config from being copied.
    // 2. After the main installDist task has run, delete the copy.
    // 3. Create the symlink.
    //
    // We depend on the actual contents of the directory being read-only,
    // otherwise they'll get deleted / zeroed by the delete command.
    delete "$buildDir/install/$applicationName/config"
    doLast {
        delete "$buildDir/install/$applicationName/config"
        def link = Paths.get("$buildDir/install/$applicationName/config")
        def target = Paths.get("$rootDir/../config").normalize()
        Files.createSymbolicLink link, target
    }
}

// Prevent the contents of the config directory from being included in the
// lib directory.
applicationDistribution.with {
    exclude 'config/**'
}
